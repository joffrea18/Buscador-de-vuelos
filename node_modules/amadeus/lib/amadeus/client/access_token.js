"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _events = _interopRequireDefault(require("events"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// The number of seconds before the token expires, when
// we will already try to refresh it
var TOKEN_BUFFER = 10;

/**
  * A helper library to create and maintain the OAuth2 AccessTokens between
  * requests. Keeps track of the expiry time and automatically tries to fetch
  * a new token if needed.
  *
  * @property {string} accessToken the cached current access token (bearer)
  * @property {number} expiresAt the aproximate time this token expires at
  * @protected
  */
var AccessToken = /*#__PURE__*/function () {
  function AccessToken() {
    _classCallCheck(this, AccessToken);
    this.accessToken;
    this.expiresAt;
  }

  // PROTECTED

  /**
   * Fetches or returns a cached bearer token. Used by the Client to get a
   * token before making an API call.
   *
   * @param  {Client} client the Amadeus Client to make an API call with
   * @return {Promise.<Response,ResponseError>} a Bluebird Promise
   * @protected
   */
  _createClass(AccessToken, [{
    key: "bearerToken",
    value: function bearerToken(client) {
      var emitter = new _events["default"]();
      var promise = this.promise(emitter);
      this.emitOrLoadAccessToken(client, emitter);
      return promise;
    }

    // PRIVATE

    /**
     * Builds a Bluebird promise to be returned to the API user
     *
     * @param  {type} emitter the EventEmitter used to notify the Promise of
     * @return {Promise} a Bluebird promise
     * @private
     */
  }, {
    key: "promise",
    value: function promise(emitter) {
      return new Promise(function (resolve, reject) {
        emitter.on('resolve', function (response) {
          return resolve(response);
        });
        emitter.on('reject', function (error) {
          return reject(error);
        });
      });
    }

    /**
     * Checks if the token needs a refresh, if not emits the cached token,
     * otherwise tries to load a new access token
     *
     * @param  {Client} client the Amadeus Client to make an API call with
     * @param  {type} emitter the EventEmitter used to emit the token
     * @private
     */
  }, {
    key: "emitOrLoadAccessToken",
    value: function emitOrLoadAccessToken(client, emitter) {
      if (this.needsLoadOrRefresh()) {
        this.loadAccessToken(client, emitter);
      } else {
        emitter.emit('resolve', this.accessToken);
      }
    }

    /**
     * Checks if the token needs a refresh or first load
     *
     * @return {boolean} wether the token needs a refresh
     * @private
     */
  }, {
    key: "needsLoadOrRefresh",
    value: function needsLoadOrRefresh() {
      if (!this.accessToken) {
        return true;
      } else if (Date.now() + TOKEN_BUFFER > this.expiresAt) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * Loads the access token using the client, emits the token when it's loaded
     *
     * @param  {Client} client the Amadeus Client to make an API call with
     * @param  {type} emitter the EventEmitter used to emit the token
     * @private
     */
  }, {
    key: "loadAccessToken",
    value: function loadAccessToken(client, emitter) {
      var _this = this;
      client.unauthenticatedRequest('POST', '/v1/security/oauth2/token', {
        'grant_type': 'client_credentials',
        'client_id': client.clientId,
        'client_secret': client.clientSecret
      }).then(function (response) {
        _this.storeAccessToken(response);
        _this.emitOrLoadAccessToken(client, emitter);
      })["catch"](function (error) {
        emitter.emit('reject', error);
      });
    }

    /**
     * Stores a loaded access token, calculating the expiry date
     *
     * @param  {Response} response the response object received from the client
     * @private
     */
  }, {
    key: "storeAccessToken",
    value: function storeAccessToken(response) {
      this.accessToken = response.result['access_token'];
      this.expiresAt = Date.now() + response.result['expires_in'] * 1000;
    }
  }]);
  return AccessToken;
}();
var _default = AccessToken;
exports["default"] = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUT0tFTl9CVUZGRVIiLCJBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuIiwiZXhwaXJlc0F0IiwiY2xpZW50IiwiZW1pdHRlciIsIkV2ZW50RW1pdHRlciIsInByb21pc2UiLCJlbWl0T3JMb2FkQWNjZXNzVG9rZW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9uIiwicmVzcG9uc2UiLCJlcnJvciIsIm5lZWRzTG9hZE9yUmVmcmVzaCIsImxvYWRBY2Nlc3NUb2tlbiIsImVtaXQiLCJEYXRlIiwibm93IiwidW5hdXRoZW50aWNhdGVkUmVxdWVzdCIsImNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwidGhlbiIsInN0b3JlQWNjZXNzVG9rZW4iLCJyZXN1bHQiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYW1hZGV1cy9jbGllbnQvYWNjZXNzX3Rva2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcblxuLy8gVGhlIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSB0aGUgdG9rZW4gZXhwaXJlcywgd2hlblxuLy8gd2Ugd2lsbCBhbHJlYWR5IHRyeSB0byByZWZyZXNoIGl0XG5jb25zdCBUT0tFTl9CVUZGRVIgPSAxMDtcblxuLyoqXG4gICogQSBoZWxwZXIgbGlicmFyeSB0byBjcmVhdGUgYW5kIG1haW50YWluIHRoZSBPQXV0aDIgQWNjZXNzVG9rZW5zIGJldHdlZW5cbiAgKiByZXF1ZXN0cy4gS2VlcHMgdHJhY2sgb2YgdGhlIGV4cGlyeSB0aW1lIGFuZCBhdXRvbWF0aWNhbGx5IHRyaWVzIHRvIGZldGNoXG4gICogYSBuZXcgdG9rZW4gaWYgbmVlZGVkLlxuICAqXG4gICogQHByb3BlcnR5IHtzdHJpbmd9IGFjY2Vzc1Rva2VuIHRoZSBjYWNoZWQgY3VycmVudCBhY2Nlc3MgdG9rZW4gKGJlYXJlcilcbiAgKiBAcHJvcGVydHkge251bWJlcn0gZXhwaXJlc0F0IHRoZSBhcHJveGltYXRlIHRpbWUgdGhpcyB0b2tlbiBleHBpcmVzIGF0XG4gICogQHByb3RlY3RlZFxuICAqL1xuY2xhc3MgQWNjZXNzVG9rZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuZXhwaXJlc0F0O1xuICB9XG5cbiAgLy8gUFJPVEVDVEVEXG5cbiAgLyoqXG4gICAqIEZldGNoZXMgb3IgcmV0dXJucyBhIGNhY2hlZCBiZWFyZXIgdG9rZW4uIFVzZWQgYnkgdGhlIENsaWVudCB0byBnZXQgYVxuICAgKiB0b2tlbiBiZWZvcmUgbWFraW5nIGFuIEFQSSBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDbGllbnR9IGNsaWVudCB0aGUgQW1hZGV1cyBDbGllbnQgdG8gbWFrZSBhbiBBUEkgY2FsbCB3aXRoXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPFJlc3BvbnNlLFJlc3BvbnNlRXJyb3I+fSBhIEJsdWViaXJkIFByb21pc2VcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYmVhcmVyVG9rZW4oY2xpZW50KSB7XG4gICAgbGV0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgbGV0IHByb21pc2UgPSB0aGlzLnByb21pc2UoZW1pdHRlcik7XG4gICAgdGhpcy5lbWl0T3JMb2FkQWNjZXNzVG9rZW4oY2xpZW50LCBlbWl0dGVyKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8vIFBSSVZBVEVcblxuICAvKipcbiAgICogQnVpbGRzIGEgQmx1ZWJpcmQgcHJvbWlzZSB0byBiZSByZXR1cm5lZCB0byB0aGUgQVBJIHVzZXJcbiAgICpcbiAgICogQHBhcmFtICB7dHlwZX0gZW1pdHRlciB0aGUgRXZlbnRFbWl0dGVyIHVzZWQgdG8gbm90aWZ5IHRoZSBQcm9taXNlIG9mXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IGEgQmx1ZWJpcmQgcHJvbWlzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvbWlzZShlbWl0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVtaXR0ZXIub24oJ3Jlc29sdmUnLCByZXNwb25zZSA9PiByZXNvbHZlKHJlc3BvbnNlKSk7XG4gICAgICBlbWl0dGVyLm9uKCdyZWplY3QnLCBlcnJvciA9PiByZWplY3QoZXJyb3IpKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdG9rZW4gbmVlZHMgYSByZWZyZXNoLCBpZiBub3QgZW1pdHMgdGhlIGNhY2hlZCB0b2tlbixcbiAgICogb3RoZXJ3aXNlIHRyaWVzIHRvIGxvYWQgYSBuZXcgYWNjZXNzIHRva2VuXG4gICAqXG4gICAqIEBwYXJhbSAge0NsaWVudH0gY2xpZW50IHRoZSBBbWFkZXVzIENsaWVudCB0byBtYWtlIGFuIEFQSSBjYWxsIHdpdGhcbiAgICogQHBhcmFtICB7dHlwZX0gZW1pdHRlciB0aGUgRXZlbnRFbWl0dGVyIHVzZWQgdG8gZW1pdCB0aGUgdG9rZW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRPckxvYWRBY2Nlc3NUb2tlbihjbGllbnQsIGVtaXR0ZXIpIHtcbiAgICBpZiAodGhpcy5uZWVkc0xvYWRPclJlZnJlc2goKSkgeyB0aGlzLmxvYWRBY2Nlc3NUb2tlbihjbGllbnQsIGVtaXR0ZXIpOyB9XG4gICAgZWxzZSB7IGVtaXR0ZXIuZW1pdCgncmVzb2x2ZScsIHRoaXMuYWNjZXNzVG9rZW4pOyB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB0b2tlbiBuZWVkcyBhIHJlZnJlc2ggb3IgZmlyc3QgbG9hZFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3ZXRoZXIgdGhlIHRva2VuIG5lZWRzIGEgcmVmcmVzaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbmVlZHNMb2FkT3JSZWZyZXNoKCkge1xuICAgIGlmICghdGhpcy5hY2Nlc3NUb2tlbikgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGVsc2UgaWYgKChEYXRlLm5vdygpICsgVE9LRU5fQlVGRkVSKSA+IHRoaXMuZXhwaXJlc0F0KSB7IHJldHVybiB0cnVlOyB9XG4gICAgZWxzZSB7IHJldHVybiBmYWxzZTsgfVxuICB9XG5cblxuICAvKipcbiAgICogTG9hZHMgdGhlIGFjY2VzcyB0b2tlbiB1c2luZyB0aGUgY2xpZW50LCBlbWl0cyB0aGUgdG9rZW4gd2hlbiBpdCdzIGxvYWRlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtDbGllbnR9IGNsaWVudCB0aGUgQW1hZGV1cyBDbGllbnQgdG8gbWFrZSBhbiBBUEkgY2FsbCB3aXRoXG4gICAqIEBwYXJhbSAge3R5cGV9IGVtaXR0ZXIgdGhlIEV2ZW50RW1pdHRlciB1c2VkIHRvIGVtaXQgdGhlIHRva2VuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsb2FkQWNjZXNzVG9rZW4oY2xpZW50LCBlbWl0dGVyKSB7XG4gICAgY2xpZW50LnVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ1BPU1QnLCAnL3YxL3NlY3VyaXR5L29hdXRoMi90b2tlbicsIHtcbiAgICAgICdncmFudF90eXBlJyA6ICdjbGllbnRfY3JlZGVudGlhbHMnLFxuICAgICAgJ2NsaWVudF9pZCcgOiBjbGllbnQuY2xpZW50SWQsXG4gICAgICAnY2xpZW50X3NlY3JldCcgOiBjbGllbnQuY2xpZW50U2VjcmV0XG4gICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIHRoaXMuc3RvcmVBY2Nlc3NUb2tlbihyZXNwb25zZSk7XG4gICAgICB0aGlzLmVtaXRPckxvYWRBY2Nlc3NUb2tlbihjbGllbnQsIGVtaXR0ZXIpO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgZW1pdHRlci5lbWl0KCdyZWplY3QnLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgbG9hZGVkIGFjY2VzcyB0b2tlbiwgY2FsY3VsYXRpbmcgdGhlIGV4cGlyeSBkYXRlXG4gICAqXG4gICAqIEBwYXJhbSAge1Jlc3BvbnNlfSByZXNwb25zZSB0aGUgcmVzcG9uc2Ugb2JqZWN0IHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RvcmVBY2Nlc3NUb2tlbihyZXNwb25zZSkge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSByZXNwb25zZS5yZXN1bHRbJ2FjY2Vzc190b2tlbiddO1xuICAgIHRoaXMuZXhwaXJlc0F0ID0gRGF0ZS5ub3coKSArIChyZXNwb25zZS5yZXN1bHRbJ2V4cGlyZXNfaW4nXSAqIDEwMDApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFjY2Vzc1Rva2VuO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUFrQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVsQztBQUNBO0FBQ0EsSUFBTUEsWUFBWSxHQUFHLEVBQUU7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBLElBU01DLFdBQVc7RUFDZix1QkFBYztJQUFBO0lBQ1osSUFBSSxDQUFDQyxXQUFXO0lBQ2hCLElBQUksQ0FBQ0MsU0FBUztFQUNoQjs7RUFFQTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEscUJBQVlDLE1BQU0sRUFBRTtNQUNsQixJQUFJQyxPQUFPLEdBQUcsSUFBSUMsa0JBQVksRUFBRTtNQUNoQyxJQUFJQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNGLE9BQU8sQ0FBQztNQUNuQyxJQUFJLENBQUNHLHFCQUFxQixDQUFDSixNQUFNLEVBQUVDLE9BQU8sQ0FBQztNQUMzQyxPQUFPRSxPQUFPO0lBQ2hCOztJQUVBOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsaUJBQVFGLE9BQU8sRUFBRTtNQUNmLE9BQU8sSUFBSUksT0FBTyxDQUFDLFVBQUNDLE9BQU8sRUFBRUMsTUFBTSxFQUFLO1FBQ3RDTixPQUFPLENBQUNPLEVBQUUsQ0FBQyxTQUFTLEVBQUUsVUFBQUMsUUFBUTtVQUFBLE9BQUlILE9BQU8sQ0FBQ0csUUFBUSxDQUFDO1FBQUEsRUFBQztRQUNwRFIsT0FBTyxDQUFDTyxFQUFFLENBQUMsUUFBUSxFQUFFLFVBQUFFLEtBQUs7VUFBQSxPQUFJSCxNQUFNLENBQUNHLEtBQUssQ0FBQztRQUFBLEVBQUM7TUFDOUMsQ0FBQyxDQUFDO0lBQ0o7O0lBR0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLCtCQUFzQlYsTUFBTSxFQUFFQyxPQUFPLEVBQUU7TUFDckMsSUFBSSxJQUFJLENBQUNVLGtCQUFrQixFQUFFLEVBQUU7UUFBRSxJQUFJLENBQUNDLGVBQWUsQ0FBQ1osTUFBTSxFQUFFQyxPQUFPLENBQUM7TUFBRSxDQUFDLE1BQ3BFO1FBQUVBLE9BQU8sQ0FBQ1ksSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUNmLFdBQVcsQ0FBQztNQUFFO0lBQ3BEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLDhCQUFxQjtNQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDQSxXQUFXLEVBQUU7UUFBRSxPQUFPLElBQUk7TUFBRSxDQUFDLE1BQ2xDLElBQUtnQixJQUFJLENBQUNDLEdBQUcsRUFBRSxHQUFHbkIsWUFBWSxHQUFJLElBQUksQ0FBQ0csU0FBUyxFQUFFO1FBQUUsT0FBTyxJQUFJO01BQUUsQ0FBQyxNQUNsRTtRQUFFLE9BQU8sS0FBSztNQUFFO0lBQ3ZCOztJQUdBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EseUJBQWdCQyxNQUFNLEVBQUVDLE9BQU8sRUFBRTtNQUFBO01BQy9CRCxNQUFNLENBQUNnQixzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsMkJBQTJCLEVBQUU7UUFDakUsWUFBWSxFQUFHLG9CQUFvQjtRQUNuQyxXQUFXLEVBQUdoQixNQUFNLENBQUNpQixRQUFRO1FBQzdCLGVBQWUsRUFBR2pCLE1BQU0sQ0FBQ2tCO01BQzNCLENBQUMsQ0FBQyxDQUFDQyxJQUFJLENBQUMsVUFBQ1YsUUFBUSxFQUFLO1FBQ3BCLEtBQUksQ0FBQ1csZ0JBQWdCLENBQUNYLFFBQVEsQ0FBQztRQUMvQixLQUFJLENBQUNMLHFCQUFxQixDQUFDSixNQUFNLEVBQUVDLE9BQU8sQ0FBQztNQUM3QyxDQUFDLENBQUMsU0FBTSxDQUFDLFVBQUNTLEtBQUssRUFBSztRQUNsQlQsT0FBTyxDQUFDWSxJQUFJLENBQUMsUUFBUSxFQUFFSCxLQUFLLENBQUM7TUFDL0IsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsMEJBQWlCRCxRQUFRLEVBQUU7TUFDekIsSUFBSSxDQUFDWCxXQUFXLEdBQUdXLFFBQVEsQ0FBQ1ksTUFBTSxDQUFDLGNBQWMsQ0FBQztNQUNsRCxJQUFJLENBQUN0QixTQUFTLEdBQUdlLElBQUksQ0FBQ0MsR0FBRyxFQUFFLEdBQUlOLFFBQVEsQ0FBQ1ksTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUs7SUFDdEU7RUFBQztFQUFBO0FBQUE7QUFBQSxlQUdZeEIsV0FBVztBQUFBO0FBQUEifQ==